// This file was auto-generated by Fern from our API Definition.

import * as GroundX from "../../src/api/index";
import { GroundXClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("Documents", () => {
    test("copy", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { toBucket: 1234 };
        const rawResponseBody = {
            ingest: { id: 1, processId: "processId", status: "queued", statusMessage: "statusMessage" },
        };
        server
            .mockEndpoint()
            .post("/v1/ingest/copy")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.copy({
            toBucket: 1234,
        });
        expect(response).toEqual({
            ingest: {
                id: 1,
                processId: "processId",
                status: "queued",
                statusMessage: "statusMessage",
            },
        });
    });

    test("ingestRemote (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            documents: [
                {
                    bucketId: 1234,
                    fileName: "my_file1.txt",
                    fileType: "txt",
                    sourceUrl: "https://my.source.url.com/file1.txt",
                },
            ],
        };
        const rawResponseBody = { ingest: { processId: "uuid", status: "queued" } };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/remote")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.ingestRemote({
            documents: [
                {
                    bucketId: 1234,
                    fileName: "my_file1.txt",
                    fileType: "txt",
                    sourceUrl: "https://my.source.url.com/file1.txt",
                },
            ],
        });
        expect(response).toEqual({
            ingest: {
                processId: "uuid",
                status: "queued",
            },
        });
    });

    test("ingestRemote (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            documents: [
                { bucketId: 1, sourceUrl: "sourceUrl" },
                { bucketId: 1, sourceUrl: "sourceUrl" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/remote")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.ingestRemote({
                documents: [
                    {
                        bucketId: 1,
                        sourceUrl: "sourceUrl",
                    },
                    {
                        bucketId: 1,
                        sourceUrl: "sourceUrl",
                    },
                ],
            });
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("ingestRemote (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            documents: [
                { bucketId: 1, sourceUrl: "sourceUrl" },
                { bucketId: 1, sourceUrl: "sourceUrl" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/remote")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.ingestRemote({
                documents: [
                    {
                        bucketId: 1,
                        sourceUrl: "sourceUrl",
                    },
                    {
                        bucketId: 1,
                        sourceUrl: "sourceUrl",
                    },
                ],
            });
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("ingestLocal (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { blob: "blob", metadata: { bucketId: 1234, fileName: "my_file1.txt", fileType: "txt" } },
        ];
        const rawResponseBody = { ingest: { processId: "uuid", status: "queued" } };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/local")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.ingestLocal([
            {
                blob: "blob",
                metadata: {
                    bucketId: 1234,
                    fileName: "my_file1.txt",
                    fileType: "txt",
                },
            },
        ]);
        expect(response).toEqual({
            ingest: {
                processId: "uuid",
                status: "queued",
            },
        });
    });

    test("ingestLocal (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { blob: "blob", metadata: {} },
            { blob: "blob", metadata: {} },
        ];
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/local")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.ingestLocal([
                {
                    blob: "blob",
                    metadata: {},
                },
                {
                    blob: "blob",
                    metadata: {},
                },
            ]);
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("ingestLocal (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { blob: "blob", metadata: {} },
            { blob: "blob", metadata: {} },
        ];
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/local")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.ingestLocal([
                {
                    blob: "blob",
                    metadata: {},
                },
                {
                    blob: "blob",
                    metadata: {},
                },
            ]);
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("crawlWebsite (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            websites: [
                {
                    bucketId: 1234,
                    cap: 10,
                    depth: 2,
                    searchData: { key: "value" },
                    sourceUrl: "https://my.website.com",
                },
            ],
        };
        const rawResponseBody = { ingest: { processId: "uuid", status: "queued" } };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/website")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.crawlWebsite({
            websites: [
                {
                    bucketId: 1234,
                    cap: 10,
                    depth: 2,
                    searchData: {
                        key: "value",
                    },
                    sourceUrl: "https://my.website.com",
                },
            ],
        });
        expect(response).toEqual({
            ingest: {
                processId: "uuid",
                status: "queued",
            },
        });
    });

    test("crawlWebsite (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            websites: [
                { bucketId: 1, sourceUrl: "sourceUrl" },
                { bucketId: 1, sourceUrl: "sourceUrl" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/website")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.crawlWebsite({
                websites: [
                    {
                        bucketId: 1,
                        sourceUrl: "sourceUrl",
                    },
                    {
                        bucketId: 1,
                        sourceUrl: "sourceUrl",
                    },
                ],
            });
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("crawlWebsite (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            websites: [
                { bucketId: 1, sourceUrl: "sourceUrl" },
                { bucketId: 1, sourceUrl: "sourceUrl" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/ingest/documents/website")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.crawlWebsite({
                websites: [
                    {
                        bucketId: 1,
                        sourceUrl: "sourceUrl",
                    },
                    {
                        bucketId: 1,
                        sourceUrl: "sourceUrl",
                    },
                ],
            });
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("list", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            documents: [
                {
                    bucketId: 1,
                    documentId: "documentId",
                    fileName: "fileName",
                    fileSize: "1.4MB",
                    fileType: "bmp",
                    filter: { key: "value", another_key: { nested: "value" } },
                    processId: "processId",
                    processLevel: "none",
                    searchData: { key: "value" },
                    sourceUrl: "sourceUrl",
                    status: "queued",
                    statusMessage: "statusMessage",
                    textUrl: "textUrl",
                    xrayUrl: "xrayUrl",
                },
            ],
            nextToken: "nextToken",
        };
        server
            .mockEndpoint()
            .get("/v1/ingest/documents")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.list({
            n: 1,
            filter: "filter",
            sort: "name",
            sortOrder: "asc",
            status: "queued",
            nextToken: "nextToken",
        });
        expect(response).toEqual({
            documents: [
                {
                    bucketId: 1,
                    documentId: "documentId",
                    fileName: "fileName",
                    fileSize: "1.4MB",
                    fileType: "bmp",
                    filter: {
                        key: "value",
                        another_key: {
                            nested: "value",
                        },
                    },
                    processId: "processId",
                    processLevel: "none",
                    searchData: {
                        key: "value",
                    },
                    sourceUrl: "sourceUrl",
                    status: "queued",
                    statusMessage: "statusMessage",
                    textUrl: "textUrl",
                    xrayUrl: "xrayUrl",
                },
            ],
            nextToken: "nextToken",
        });
    });

    test("delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { ingest: { processId: "uuid", status: "queued" } };
        server
            .mockEndpoint()
            .delete("/v1/ingest/documents")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.delete({
            documentIds: "123e4567-e89b-12d3-a456-426614174000,9f7c11a6-24b8-4d52-a9f3-90a7e70a9e49",
        });
        expect(response).toEqual({
            ingest: {
                processId: "uuid",
                status: "queued",
            },
        });
    });

    test("delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/ingest/documents")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.delete();
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("delete (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/ingest/documents")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.delete();
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("getProcessingStatusById (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            ingest: { id: 1, processId: "processId", status: "queued", statusMessage: "statusMessage" },
        };
        server
            .mockEndpoint()
            .get("/v1/ingest/processId")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.getProcessingStatusById("processId");
        expect(response).toEqual({
            ingest: {
                id: 1,
                processId: "processId",
                status: "queued",
                statusMessage: "statusMessage",
            },
        });
    });

    test("getProcessingStatusById (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/ingest/processId")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.getProcessingStatusById("processId");
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("getProcessingStatusById (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/ingest/processId")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.getProcessingStatusById("processId");
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("cancelProcess (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            ingest: { id: 1, processId: "processId", status: "queued", statusMessage: "statusMessage" },
        };
        server
            .mockEndpoint()
            .delete("/v1/ingest/processId")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.cancelProcess("processId");
        expect(response).toEqual({
            ingest: {
                id: 1,
                processId: "processId",
                status: "queued",
                statusMessage: "statusMessage",
            },
        });
    });

    test("cancelProcess (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/ingest/processId")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.cancelProcess("processId");
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("cancelProcess (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/ingest/processId")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.cancelProcess("processId");
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("lookup (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            count: 20,
            documents: [
                {
                    bucketId: 1,
                    documentId: "documentId",
                    fileName: "fileName",
                    fileSize: "1.4MB",
                    fileType: "bmp",
                    filter: { key: "value", another_key: { nested: "value" } },
                    processId: "processId",
                    processLevel: "none",
                    searchData: { key: "value" },
                    sourceUrl: "sourceUrl",
                    status: "queued",
                    statusMessage: "statusMessage",
                    textUrl: "textUrl",
                    xrayUrl: "xrayUrl",
                },
            ],
            nextToken: "nHXtu=",
            remaining: 10,
            total: 30,
        };
        server
            .mockEndpoint()
            .get("/v1/ingest/documents/1")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.lookup(1, {
            n: 1,
            filter: "filter",
            sort: "name",
            sortOrder: "asc",
            status: "queued",
            nextToken: "nextToken",
        });
        expect(response).toEqual({
            count: 20,
            documents: [
                {
                    bucketId: 1,
                    documentId: "documentId",
                    fileName: "fileName",
                    fileSize: "1.4MB",
                    fileType: "bmp",
                    filter: {
                        key: "value",
                        another_key: {
                            nested: "value",
                        },
                    },
                    processId: "processId",
                    processLevel: "none",
                    searchData: {
                        key: "value",
                    },
                    sourceUrl: "sourceUrl",
                    status: "queued",
                    statusMessage: "statusMessage",
                    textUrl: "textUrl",
                    xrayUrl: "xrayUrl",
                },
            ],
            nextToken: "nHXtu=",
            remaining: 10,
            total: 30,
        });
    });

    test("lookup (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/ingest/documents/1")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.lookup(1);
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("lookup (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/ingest/documents/1")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.lookup(1);
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            document: {
                bucketId: 1,
                documentId: "documentId",
                fileName: "fileName",
                fileSize: "1.4MB",
                fileType: "bmp",
                filter: { key: "value", another_key: { nested: "value" } },
                processId: "processId",
                processLevel: "none",
                searchData: { key: "value" },
                sourceUrl: "sourceUrl",
                status: "queued",
                statusMessage: "statusMessage",
                textUrl: "textUrl",
                xrayUrl: "xrayUrl",
            },
        };
        server
            .mockEndpoint()
            .get("/v1/ingest/document/documentId")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.get("documentId");
        expect(response).toEqual({
            document: {
                bucketId: 1,
                documentId: "documentId",
                fileName: "fileName",
                fileSize: "1.4MB",
                fileType: "bmp",
                filter: {
                    key: "value",
                    another_key: {
                        nested: "value",
                    },
                },
                processId: "processId",
                processLevel: "none",
                searchData: {
                    key: "value",
                },
                sourceUrl: "sourceUrl",
                status: "queued",
                statusMessage: "statusMessage",
                textUrl: "textUrl",
                xrayUrl: "xrayUrl",
            },
        });
    });

    test("get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/ingest/document/documentId")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.get("documentId");
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("get (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/ingest/document/documentId")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.get("documentId");
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("deleteById (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            ingest: { id: 1, processId: "processId", status: "queued", statusMessage: "statusMessage" },
        };
        server
            .mockEndpoint()
            .delete("/v1/ingest/document/documentId")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.deleteById("documentId");
        expect(response).toEqual({
            ingest: {
                id: 1,
                processId: "processId",
                status: "queued",
                statusMessage: "statusMessage",
            },
        });
    });

    test("deleteById (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/ingest/document/documentId")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.deleteById("documentId");
        }).rejects.toThrow(GroundX.BadRequestError);
    });

    test("deleteById (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/ingest/document/documentId")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.deleteById("documentId");
        }).rejects.toThrow(GroundX.UnauthorizedError);
    });

    test("getProcesses", async () => {
        const server = mockServerPool.createServer();
        const client = new GroundXClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            processes: [{ id: 1, processId: "processId", status: "queued", statusMessage: "statusMessage" }],
        };
        server.mockEndpoint().get("/v1/ingest").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.documents.getProcesses({
            n: 1,
            status: "queued",
        });
        expect(response).toEqual({
            processes: [
                {
                    id: 1,
                    processId: "processId",
                    status: "queued",
                    statusMessage: "statusMessage",
                },
            ],
        });
    });
});
