// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as GroundX from "../../../index.js";

export declare namespace DocumentsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class DocumentsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<DocumentsClient.Options>;

    constructor(options: DocumentsClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * copy documents from one bucket to another
     *
     * @param {GroundX.DocumentCopyRequest} request
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.documents.copy({
     *         toBucket: 1234
     *     })
     */
    public copy(
        request: GroundX.DocumentCopyRequest,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.IngestResponse> {
        return core.HttpResponsePromise.fromPromise(this.__copy(request, requestOptions));
    }

    private async __copy(
        request: GroundX.DocumentCopyRequest,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.IngestResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                "v1/ingest/copy",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.IngestResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.GroundXError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v1/ingest/copy");
    }

    /**
     * Ingest documents hosted on public URLs into a GroundX bucket.
     *
     * [Supported Document Types and Ingest Capacities](https://docs.eyelevel.ai/documentation/fundamentals/document-types-and-ingest-capacities)
     *
     * @param {GroundX.DocumentRemoteIngestRequest} request
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.ingestRemote({
     *         documents: [{
     *                 bucketId: 1234,
     *                 fileName: "my_file1.txt",
     *                 fileType: "txt",
     *                 sourceUrl: "https://my.source.url.com/file1.txt"
     *             }]
     *     })
     */
    public ingestRemote(
        request: GroundX.DocumentRemoteIngestRequest,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.IngestResponse> {
        return core.HttpResponsePromise.fromPromise(this.__ingestRemote(request, requestOptions));
    }

    private async __ingestRemote(
        request: GroundX.DocumentRemoteIngestRequest,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.IngestResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                "v1/ingest/documents/remote",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.IngestResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v1/ingest/documents/remote");
    }

    /**
     * Upload documents hosted on a local file system into a GroundX bucket.
     *
     * [Supported Document Types and Ingest Capacities](https://docs.eyelevel.ai/documentation/fundamentals/document-types-and-ingest-capacities)
     *
     * @param {GroundX.DocumentLocalIngestRequest} request
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.ingestLocal([{
     *             blob: "blob",
     *             metadata: {
     *                 bucketId: 1234,
     *                 fileName: "my_file1.txt",
     *                 fileType: "txt"
     *             }
     *         }])
     */
    public ingestLocal(
        request: GroundX.DocumentLocalIngestRequest,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.IngestResponse> {
        return core.HttpResponsePromise.fromPromise(this.__ingestLocal(request, requestOptions));
    }

    private async __ingestLocal(
        request: GroundX.DocumentLocalIngestRequest,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.IngestResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                "v1/ingest/documents/local",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.IngestResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v1/ingest/documents/local");
    }

    /**
     * Upload the content of a publicly accessible website for ingestion into a GroundX bucket. This is done by following links within a specified URL, recursively, up to a specified depth or number of pages.
     *
     * Note1: This endpoint is currently not supported for on-prem deployments.
     * Note2: The `source_url` must include the protocol, http:// or https://.
     *
     * [Supported Document Types and Ingest Capacities](https://docs.eyelevel.ai/documentation/fundamentals/document-types-and-ingest-capacities)
     *
     * @param {GroundX.WebsiteCrawlRequest} request
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.crawlWebsite({
     *         websites: [{
     *                 bucketId: 1234,
     *                 cap: 10,
     *                 depth: 2,
     *                 searchData: {
     *                     "key": "value"
     *                 },
     *                 sourceUrl: "https://my.website.com"
     *             }]
     *     })
     */
    public crawlWebsite(
        request: GroundX.WebsiteCrawlRequest,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.IngestResponse> {
        return core.HttpResponsePromise.fromPromise(this.__crawlWebsite(request, requestOptions));
    }

    private async __crawlWebsite(
        request: GroundX.WebsiteCrawlRequest,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.IngestResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                "v1/ingest/documents/website",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.IngestResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v1/ingest/documents/website");
    }

    /**
     * lookup all documents across all resources which are currently on GroundX
     *
     * @param {GroundX.DocumentsListRequest} request
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.documents.list({
     *         n: 1,
     *         filter: "filter",
     *         sort: "name",
     *         sortOrder: "asc",
     *         status: "queued",
     *         nextToken: "nextToken"
     *     })
     */
    public list(
        request: GroundX.DocumentsListRequest = {},
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.DocumentListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: GroundX.DocumentsListRequest = {},
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.DocumentListResponse>> {
        const { n, filter, sort, sortOrder, status, nextToken } = request;
        const _queryParams: Record<string, unknown> = {
            n,
            filter,
            sort: sort != null ? sort : undefined,
            sortOrder: sortOrder != null ? sortOrder : undefined,
            status: status != null ? status : undefined,
            nextToken,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                "v1/ingest/documents",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.DocumentListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.GroundXError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v1/ingest/documents");
    }

    /**
     * Delete multiple documents hosted on GroundX
     *
     * @param {GroundX.DocumentsDeleteRequest} request
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.delete({
     *         documentIds: "123e4567-e89b-12d3-a456-426614174000,9f7c11a6-24b8-4d52-a9f3-90a7e70a9e49"
     *     })
     */
    public delete(
        request: GroundX.DocumentsDeleteRequest = {},
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.IngestResponse> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: GroundX.DocumentsDeleteRequest = {},
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.IngestResponse>> {
        const { documentIds } = request;
        const _queryParams: Record<string, unknown> = {
            documentIds,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                "v1/ingest/documents",
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.IngestResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v1/ingest/documents");
    }

    /**
     * Get the current status of an ingest, initiated with documents.ingest_remote, documents.ingest_local, or documents.crawl_website, by specifying the processId (the processId is included in the response of the documents.ingest functions).
     *
     * @param {string} processId - the processId for the ingest process being checked
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.getProcessingStatusById("processId")
     */
    public getProcessingStatusById(
        processId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.IngestResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getProcessingStatusById(processId, requestOptions));
    }

    private async __getProcessingStatusById(
        processId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.IngestResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                `v1/ingest/${core.url.encodePathParam(processId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.IngestResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v1/ingest/{processId}");
    }

    /**
     * Cancel an ingest process, along with any files that have not been completely ingested.
     *
     * @param {string} processId - the processId for the ingest process to be cancelled
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.cancelProcess("processId")
     */
    public cancelProcess(
        processId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.IngestResponse> {
        return core.HttpResponsePromise.fromPromise(this.__cancelProcess(processId, requestOptions));
    }

    private async __cancelProcess(
        processId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.IngestResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                `v1/ingest/${core.url.encodePathParam(processId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.IngestResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v1/ingest/{processId}");
    }

    /**
     * lookup the document(s) associated with a processId, bucketId, or groupId.
     *
     * @param {number} id - a processId, bucketId, or groupId
     * @param {GroundX.DocumentsLookupRequest} request
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.lookup(1, {
     *         n: 1,
     *         filter: "filter",
     *         sort: "name",
     *         sortOrder: "asc",
     *         status: "queued",
     *         nextToken: "nextToken"
     *     })
     */
    public lookup(
        id: number,
        request: GroundX.DocumentsLookupRequest = {},
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.DocumentLookupResponse> {
        return core.HttpResponsePromise.fromPromise(this.__lookup(id, request, requestOptions));
    }

    private async __lookup(
        id: number,
        request: GroundX.DocumentsLookupRequest = {},
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.DocumentLookupResponse>> {
        const { n, filter, sort, sortOrder, status, nextToken } = request;
        const _queryParams: Record<string, unknown> = {
            n,
            filter,
            sort: sort != null ? sort : undefined,
            sortOrder: sortOrder != null ? sortOrder : undefined,
            status: status != null ? status : undefined,
            nextToken,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                `v1/ingest/documents/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.DocumentLookupResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v1/ingest/documents/{id}");
    }

    /**
     * Look up an existing document by documentId.
     *
     * @param {string} documentId - The documentId of the document for which GroundX information will be provided.
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.get("documentId")
     */
    public get(
        documentId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.DocumentResponse> {
        return core.HttpResponsePromise.fromPromise(this.__get(documentId, requestOptions));
    }

    private async __get(
        documentId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.DocumentResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                `v1/ingest/document/${core.url.encodePathParam(documentId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.DocumentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/ingest/document/{documentId}",
        );
    }

    /**
     * Delete a single document hosted on GroundX
     *
     * @param {string} documentId - A documentId which correspond to a document ingested by GroundX
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.deleteById("documentId")
     */
    public deleteById(
        documentId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.IngestResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteById(documentId, requestOptions));
    }

    private async __deleteById(
        documentId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.IngestResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                `v1/ingest/document/${core.url.encodePathParam(documentId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.IngestResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/v1/ingest/document/{documentId}",
        );
    }

    /**
     * Look up extractions for an existing document by documentId.
     *
     * @param {string} documentId - The documentId of the document for which GroundX extract has extracted information.
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.getExtract("documentId")
     */
    public getExtract(
        documentId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(this.__getExtract(documentId, requestOptions));
    }

    private async __getExtract(
        documentId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                `v1/ingest/document/extract/${core.url.encodePathParam(documentId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/ingest/document/extract/{documentId}",
        );
    }

    /**
     * Look up X-Ray data for an existing document by documentId.
     *
     * @param {string} documentId - The documentId of the document for which GroundX created an X-Ray.
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link GroundX.BadRequestError}
     * @throws {@link GroundX.UnauthorizedError}
     *
     * @example
     *     await client.documents.getXray("documentId")
     */
    public getXray(
        documentId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(this.__getXray(documentId, requestOptions));
    }

    private async __getXray(
        documentId: string,
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                `v1/ingest/document/xray/${core.url.encodePathParam(documentId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new GroundX.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new GroundX.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.GroundXError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/ingest/document/xray/{documentId}",
        );
    }

    /**
     * Get a list of ingest process requests, sorted from most recent to least.
     *
     * @param {GroundX.DocumentsGetProcessesRequest} request
     * @param {DocumentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.documents.getProcesses({
     *         n: 1,
     *         status: "queued"
     *     })
     */
    public getProcesses(
        request: GroundX.DocumentsGetProcessesRequest = {},
        requestOptions?: DocumentsClient.RequestOptions,
    ): core.HttpResponsePromise<GroundX.ProcessesStatusResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getProcesses(request, requestOptions));
    }

    private async __getProcesses(
        request: GroundX.DocumentsGetProcessesRequest = {},
        requestOptions?: DocumentsClient.RequestOptions,
    ): Promise<core.WithRawResponse<GroundX.ProcessesStatusResponse>> {
        const { n, status } = request;
        const _queryParams: Record<string, unknown> = {
            n,
            status: status != null ? status : undefined,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.GroundXEnvironment.Default,
                "v1/ingest",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as GroundX.ProcessesStatusResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.GroundXError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v1/ingest");
    }
}
